name: Create release from matrix updates

on:
  workflow_call:
    inputs:
      targets_json:
        description: "JSON array of target metadata (name, workdir, changed, docker_tag, etc.)"
        required: false
        default: ""
        type: string
    outputs:
      tag:
        description: Tag used for the release
        value: ${{ jobs.create-release.outputs.tag }}

env:
  GH_TOKEN: ${{ github.token }}

jobs:
  aggregate-changes:
    name: Aggregate changes
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      changed_any: ${{ steps.collect.outputs.changed_any }}
      docker_tags: ${{ steps.collect.outputs.docker_tags }}
      proposed_tags: ${{ steps.collect.outputs.proposed_tags }}
      images: ${{ steps.collect.outputs.images }}
      targets_json: ${{ steps.collect.outputs.targets_json }}
      meta_found: ${{ steps.collect.outputs.meta_found }}
      committed: ${{ steps.commit.outputs.committed }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - &resolve_cicd
        name: Resolve CICD helper repo
        run: |
          repo="snw35/cicd"
          ref="${GITHUB_WORKFLOW_REF##*@}"
          if [ -z "$ref" ] || [ "$ref" = "$GITHUB_WORKFLOW_REF" ]; then
            if [ "$GITHUB_REPOSITORY" = "$repo" ] && [ -n "$GITHUB_REF_NAME" ]; then
              ref="${GITHUB_REF_NAME}"
            else
              ref="mainline"
            fi
          fi
          if [ "$repo" = "$GITHUB_REPOSITORY" ] && [ -d "${GITHUB_WORKSPACE}/.github/scripts" ]; then
            repo_dir="${GITHUB_WORKSPACE}"
            scripts_dir="${repo_dir}/.github/scripts"
            need_checkout="false"
          else
            repo_dir="${GITHUB_WORKSPACE}/.cicd"
            scripts_dir="${repo_dir}/.github/scripts"
            need_checkout="true"
          fi
          {
            echo "CICD_REPO=$repo"
            echo "CICD_REF=$ref"
            echo "CICD_REPO_DIR=$repo_dir"
            echo "CICD_SCRIPTS_DIR=$scripts_dir"
            echo "CICD_NEED_CHECKOUT=$need_checkout"
          } >> "$GITHUB_ENV"
      - &checkout_cicd
        name: Checkout CICD scripts
        if: env.CICD_NEED_CHECKOUT == 'true'
        uses: actions/checkout@v4
        with:
          repository: ${{ env.CICD_REPO }}
          ref: ${{ env.CICD_REF }}
          token: ${{ secrets.GITHUB_TOKEN || secrets.GH_TOKEN || github.token }}
          path: .cicd
          fetch-depth: 1
      - &ignore_cicd
        name: Ignore CICD helper checkout
        if: env.CICD_NEED_CHECKOUT == 'true'
        run: |
          exclude_file="${GITHUB_WORKSPACE}/.git/info/exclude"
          if [ -f "${exclude_file}" ] && ! grep -qx "/.cicd/" "${exclude_file}"; then
            echo "/.cicd/" >> "${exclude_file}"
          fi
      - uses: actions/download-artifact@v4
        with:
          pattern: update-*-${{ github.run_attempt }}
          path: /tmp/updates
          merge-multiple: true
        continue-on-error: true
      - id: collect
        env:
          UPDATES_DIR: /tmp/updates
        run: python3 "$CICD_SCRIPTS_DIR/collect_updates.py"
      - name: Apply aggregated patches
        if: steps.collect.outputs.meta_found == 'true'
        run: |
          shopt -s nullglob
          for patch in /tmp/updates/*-changes.patch; do
            git apply --binary "$patch"
          done
      - name: Commit aggregated changes
        id: commit
        if: steps.collect.outputs.meta_found == 'true'
        run: |
          if git status --porcelain | grep -q .; then
            git config --local user.name "$GITHUB_REPOSITORY_OWNER"
            git config --local user.email "snw35@use.startmail.com"
            git add -A
            git commit -m "Automated container updates"
            echo "committed=true" >> "$GITHUB_OUTPUT"
          else
            echo "No changes to commit."
            echo "committed=false" >> "$GITHUB_OUTPUT"
          fi
      - name: Push commits and tags
        if: steps.collect.outputs.meta_found == 'true'
        run: |
          git remote add upstream "https://${GH_TOKEN}@github.com/${GITHUB_REPOSITORY}.git" > /dev/null 2>&1
          if [ "${{ steps.commit.outputs.committed }}" = "true" ]; then
            # Rebase onto latest upstream to avoid non-fast-forward failures when multiple runs push
            git fetch upstream "${GITHUB_REF_NAME}"
            git rebase "upstream/${GITHUB_REF_NAME}"
            git push --quiet --set-upstream upstream HEAD
          else
            echo "No commits to push."
          fi

  create-release:
    name: Create release
    needs: aggregate-changes
    # Only run when the aggregated changes report an update or missing tag
    if: needs.aggregate-changes.outputs.changed_any == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      tag: ${{ steps.pick_tag.outputs.tag }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - *resolve_cicd
      - *checkout_cicd
      - *ignore_cicd
      - name: Pick combined release tag from changed targets
        id: pick_tag
        env:
          TARGETS_JSON: ${{ needs.aggregate-changes.outputs.targets_json != '' && needs.aggregate-changes.outputs.targets_json || inputs.targets_json }}
        run: |
          tag="$(python3 "$CICD_SCRIPTS_DIR/pick_release_tag.py")"
          if [ -n "$tag" ]; then
            echo "tag=$tag" >> "$GITHUB_OUTPUT"
          else
            echo "No changed targets found; skipping tag creation."
          fi
      - name: Sync release tag to latest commit
        if: steps.pick_tag.outputs.tag != ''
        run: |
          tag="${{ steps.pick_tag.outputs.tag }}"
          git fetch origin "${GITHUB_REF_NAME}"
          git checkout -B release-tag "origin/${GITHUB_REF_NAME}"
          git tag -f "$tag"
          git push --force origin "refs/tags/${tag}"
      - uses: softprops/action-gh-release@v2
        if: steps.pick_tag.outputs.tag != ''
        with:
          tag_name: ${{ steps.pick_tag.outputs.tag }}
          name: Release ${{ steps.pick_tag.outputs.tag }}
          body: Automated release for ${{ steps.pick_tag.outputs.tag }}
          target_commitish: ${{ github.ref_name }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
