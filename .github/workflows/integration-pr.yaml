name: Integration PR

on:
  pull_request:
    types: [opened, synchronize, reopened]

concurrency:
  group: integration-pr-${{ github.event.pull_request.number }}
  cancel-in-progress: true

jobs:
  integration:
    name: Run upstream integration workflow
    if: github.event.pull_request.head.repo.full_name == github.repository
    runs-on: ubuntu-latest
    permissions:
      contents: read
    env:
      INTEGRATION_OWNER: snw35
      INTEGRATION_REPO: cicd-integration
      INTEGRATION_WORKFLOW: integration-update.yaml
      INTEGRATION_BASE_REF: main
      POLL_INTERVAL_MS: 15000
      WAIT_TIMEOUT_MS: 3600000
    steps:
      - name: Prepare integration ref and dispatch workflow
        id: dispatch
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CICD_INTEGRATION_TOKEN }}
          script: |
            const owner = process.env.INTEGRATION_OWNER;
            const repo = process.env.INTEGRATION_REPO;
            const workflow_id = process.env.INTEGRATION_WORKFLOW;
            const baseRef = process.env.INTEGRATION_BASE_REF || 'main';
            const cicdRef = context.payload.pull_request.head.sha;
            const prNumber = context.payload.pull_request.number;
            const workflowRunId = context.runId;
            const tempRef = `integration-pr-${prNumber}-${workflowRunId}`;
            const workflowPath = '.github/workflows/integration-update.yaml';

            const resetBranchFromBase = async (branch, sourceBranch) => {
              const base = await github.rest.git.getRef({
                owner,
                repo,
                ref: `heads/${sourceBranch}`
              });
              const baseSha = base.data.object.sha;

              try {
                await github.rest.git.createRef({
                  owner,
                  repo,
                  ref: `refs/heads/${branch}`,
                  sha: baseSha
                });
              } catch (error) {
                if (error.status !== 422) {
                  throw error;
                }
                await github.rest.git.updateRef({
                  owner,
                  repo,
                  ref: `heads/${branch}`,
                  sha: baseSha,
                  force: true
                });
              }
            };

            const rewriteReusableRef = (yaml, workflowName, refValue) => {
              const pattern = new RegExp(
                `uses:\\s*snw35\\/cicd\\/\\.github\\/workflows\\/${workflowName}@[\\S]+`,
                'g'
              );
              const matches = yaml.match(pattern) || [];
              if (matches.length !== 1) {
                throw new Error(
                  `Expected exactly one uses ref for ${workflowName} in ${workflowPath}, found ${matches.length}.`
                );
              }
              return yaml.replace(
                pattern,
                `uses: snw35/cicd/.github/workflows/${workflowName}@${refValue}`
              );
            };

            await resetBranchFromBase(tempRef, baseRef);

            const baseWorkflow = await github.rest.repos.getContent({
              owner,
              repo,
              path: workflowPath,
              ref: baseRef
            });

            if (
              Array.isArray(baseWorkflow.data)
              || !('content' in baseWorkflow.data)
              || !('sha' in baseWorkflow.data)
            ) {
              throw new Error('Expected integration-update workflow file content and sha.');
            }

            let workflowYaml = Buffer.from(baseWorkflow.data.content, 'base64').toString('utf8');
            workflowYaml = rewriteReusableRef(workflowYaml, 'github.yaml', cicdRef);
            workflowYaml = rewriteReusableRef(workflowYaml, 'create-release.yaml', cicdRef);

            await github.rest.repos.createOrUpdateFileContents({
              owner,
              repo,
              path: workflowPath,
              branch: tempRef,
              message: `ci: use cicd ref ${cicdRef} for integration PR #${prNumber}`,
              content: Buffer.from(workflowYaml).toString('base64'),
              sha: baseWorkflow.data.sha
            });

            const now = new Date().toISOString();
            core.info(`Dispatching ${owner}/${repo} ${workflow_id}@${tempRef} with cicd_ref=${cicdRef}`);
            await github.rest.actions.createWorkflowDispatch({
              owner,
              repo,
              workflow_id,
              ref: tempRef,
              inputs: {
                cicd_ref: cicdRef
              }
            });
            core.setOutput('dispatch_time', now);
            core.setOutput('integration_ref', tempRef);
      - name: Wait for integration workflow
        uses: actions/github-script@v7
        env:
          DISPATCH_TIME: ${{ steps.dispatch.outputs.dispatch_time }}
          DISPATCH_REF: ${{ steps.dispatch.outputs.integration_ref }}
        with:
          github-token: ${{ secrets.CICD_INTEGRATION_TOKEN }}
          script: |
            const owner = process.env.INTEGRATION_OWNER;
            const repo = process.env.INTEGRATION_REPO;
            const workflow_id = process.env.INTEGRATION_WORKFLOW;
            const branch = process.env.DISPATCH_REF;
            const dispatchTime = new Date(process.env.DISPATCH_TIME);
            const timeoutMs = parseInt(process.env.WAIT_TIMEOUT_MS || '3600000', 10);
            const pollMs = parseInt(process.env.POLL_INTERVAL_MS || '15000', 10);
            const deadline = Date.now() + timeoutMs;
            const skewMs = 5000;
            let runId = null;

            if (!branch || Number.isNaN(dispatchTime.getTime())) {
              core.setFailed('Missing dispatch metadata (branch and/or dispatch time).');
              return;
            }

            const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

            while (Date.now() < deadline) {
              if (!runId) {
                const runs = await github.rest.actions.listWorkflowRuns({
                  owner,
                  repo,
                  workflow_id,
                  branch,
                  event: 'workflow_dispatch',
                  per_page: 10
                });
                const candidate = runs.data.workflow_runs.find((run) => {
                  return new Date(run.created_at).getTime() >= dispatchTime.getTime() - skewMs;
                });
                if (candidate) {
                  runId = candidate.id;
                  core.info(`Found integration run ${runId} (${candidate.html_url}).`);
                }
              }
              if (runId) {
                const run = await github.rest.actions.getWorkflowRun({
                  owner,
                  repo,
                  run_id: runId
                });
                core.info(`Integration run status: ${run.data.status} (${run.data.conclusion || 'pending'}).`);
                if (run.data.status === 'completed') {
                  if (run.data.conclusion !== 'success') {
                    core.setFailed(`Integration workflow concluded with ${run.data.conclusion}.`);
                  }
                  return;
                }
              }
              await sleep(pollMs);
            }

            core.setFailed('Timed out waiting for integration workflow to complete.');
