name: Integration PR

on:
  pull_request:
    types: [opened, synchronize, reopened]

concurrency:
  group: integration-pr-${{ github.event.pull_request.number }}
  cancel-in-progress: true

jobs:
  integration:
    name: Run upstream integration workflow
    if: github.event.pull_request.head.repo.full_name == github.repository
    runs-on: ubuntu-latest
    permissions:
      contents: read
    env:
      CICD_REF: ${{ github.event.pull_request.head.ref }}
      PR_NUMBER: ${{ github.event.pull_request.number }}
      INTEGRATION_OWNER: snw35
      INTEGRATION_REPO: cicd-integration
      INTEGRATION_WORKFLOW: integration-update.yaml
      INTEGRATION_BASE_REF: main
      POLL_INTERVAL_MS: 15000
      WAIT_TIMEOUT_MS: 3600000
    steps:
      - name: Dispatch integration workflow
        id: dispatch
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CICD_INTEGRATION_TOKEN }}
          script: |
            const owner = process.env.INTEGRATION_OWNER;
            const repo = process.env.INTEGRATION_REPO;
            const workflow_id = process.env.INTEGRATION_WORKFLOW;
            const baseRef = process.env.INTEGRATION_BASE_REF || 'main';
            const cicdRef = process.env.CICD_REF;
            const prNumber = process.env.PR_NUMBER;
            let ref = baseRef;

            const ensureBranchFromBase = async (branch, sourceBranch) => {
              const base = await github.rest.git.getRef({
                owner,
                repo,
                ref: `heads/${sourceBranch}`
              });
              const baseSha = base.data.object.sha;
              try {
                await github.rest.git.getRef({
                  owner,
                  repo,
                  ref: `heads/${branch}`
                });
                await github.rest.git.updateRef({
                  owner,
                  repo,
                  ref: `heads/${branch}`,
                  sha: baseSha,
                  force: true
                });
              } catch (error) {
                if (error.status !== 404) {
                  throw error;
                }
                await github.rest.git.createRef({
                  owner,
                  repo,
                  ref: `refs/heads/${branch}`,
                  sha: baseSha
                });
              }
            };

            if (cicdRef && cicdRef !== 'main') {
              const tempRef = `integration-pr-${prNumber}`;
              const workflowPath = '.github/workflows/integration-update.yaml';

              await ensureBranchFromBase(tempRef, baseRef);

              const baseWorkflow = await github.rest.repos.getContent({
                owner,
                repo,
                path: workflowPath,
                ref: baseRef
              });

              if (Array.isArray(baseWorkflow.data) || !('content' in baseWorkflow.data)) {
                throw new Error('Expected integration-update workflow file content.');
              }

              let workflowYaml = Buffer.from(baseWorkflow.data.content, 'base64').toString('utf8');
              workflowYaml = workflowYaml
                .replace(
                  'uses: snw35/cicd/.github/workflows/github.yaml@main',
                  `uses: snw35/cicd/.github/workflows/github.yaml@${cicdRef}`
                )
                .replace(
                  'uses: snw35/cicd/.github/workflows/create-release.yaml@main',
                  `uses: snw35/cicd/.github/workflows/create-release.yaml@${cicdRef}`
                );

              let currentSha;
              try {
                const currentWorkflow = await github.rest.repos.getContent({
                  owner,
                  repo,
                  path: workflowPath,
                  ref: tempRef
                });
                if (!Array.isArray(currentWorkflow.data) && 'sha' in currentWorkflow.data) {
                  currentSha = currentWorkflow.data.sha;
                }
              } catch (error) {
                if (error.status !== 404) {
                  throw error;
                }
              }

              await github.rest.repos.createOrUpdateFileContents({
                owner,
                repo,
                path: workflowPath,
                branch: tempRef,
                message: `ci: use cicd ref ${cicdRef} for integration PR #${prNumber}`,
                content: Buffer.from(workflowYaml).toString('base64'),
                sha: currentSha
              });

              ref = tempRef;
            }

            const now = new Date().toISOString();
            core.info(`Dispatching ${owner}/${repo} ${workflow_id}@${ref} with cicd_ref=${cicdRef}`);
            await github.rest.actions.createWorkflowDispatch({
              owner,
              repo,
              workflow_id,
              ref,
              inputs: {
                cicd_ref: cicdRef
              }
            });
            core.setOutput('dispatch_time', now);
            core.setOutput('integration_ref', ref);
      - name: Wait for integration workflow
        uses: actions/github-script@v7
        env:
          DISPATCH_TIME: ${{ steps.dispatch.outputs.dispatch_time }}
          DISPATCH_REF: ${{ steps.dispatch.outputs.integration_ref }}
        with:
          github-token: ${{ secrets.CICD_INTEGRATION_TOKEN }}
          script: |
            const owner = process.env.INTEGRATION_OWNER;
            const repo = process.env.INTEGRATION_REPO;
            const workflow_id = process.env.INTEGRATION_WORKFLOW;
            const branch = process.env.DISPATCH_REF || process.env.INTEGRATION_BASE_REF;
            const dispatchTime = new Date(process.env.DISPATCH_TIME);
            const timeoutMs = parseInt(process.env.WAIT_TIMEOUT_MS || '3600000', 10);
            const pollMs = parseInt(process.env.POLL_INTERVAL_MS || '15000', 10);
            const deadline = Date.now() + timeoutMs;
            const skewMs = 5000;
            let runId = null;

            const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

            while (Date.now() < deadline) {
              if (!runId) {
                const runs = await github.rest.actions.listWorkflowRuns({
                  owner,
                  repo,
                  workflow_id,
                  branch,
                  event: 'workflow_dispatch',
                  per_page: 10
                });
                const candidate = runs.data.workflow_runs.find((run) => {
                  return new Date(run.created_at).getTime() >= dispatchTime.getTime() - skewMs;
                });
                if (candidate) {
                  runId = candidate.id;
                  core.info(`Found integration run ${runId} (${candidate.html_url}).`);
                }
              }
              if (runId) {
                const run = await github.rest.actions.getWorkflowRun({
                  owner,
                  repo,
                  run_id: runId
                });
                core.info(`Integration run status: ${run.data.status} (${run.data.conclusion || 'pending'}).`);
                if (run.data.status === 'completed') {
                  if (run.data.conclusion !== 'success') {
                    core.setFailed(`Integration workflow concluded with ${run.data.conclusion}.`);
                  }
                  return;
                }
              }
              await sleep(pollMs);
            }

            core.setFailed('Timed out waiting for integration workflow to complete.');
