name: Reuseable container workflow

env:
  NVCHECKER_VERSION: 2.19
  DFUPDATE_VERSION: 2.2.2
  GH_TOKEN: ${{ github.token }}
  CICD_TEST_MODE: ${{ inputs.CICD_TEST_MODE }}

# Provide inputs that control image tagging
on:
  workflow_call:
    outputs:
      changed:
        description: Whether any matrix target detected Dockerfile changes or a missing tag
        value: ${{ jobs.collect-metadata.outputs.changed_any }}
      docker_tag:
        description: JSON map of Docker tags keyed by target name
        value: ${{ jobs.collect-metadata.outputs.docker_tags }}
      proposed_tag:
        description: JSON map of proposed tags keyed by target name
        value: ${{ jobs.collect-metadata.outputs.proposed_tags }}
      image:
        description: JSON map of full image references keyed by target name
        value: ${{ jobs.collect-metadata.outputs.images }}
      targets:
        description: JSON array of target metadata (name, workdir, changed, tag_exists, docker_tag, proposed_tag, image)
        value: ${{ jobs.collect-metadata.outputs.targets_json }}
    inputs:
      # Provide a bash command that will create the image tag
      TAG_COMMAND:
        required: false
        type: string
      # Provide a Dockerfile ENV var that will be used for the image tag
      IMAGE_TAG:
        required: false
        type: string
      TARGETS_JSON:
        required: false
        type: string
        description: JSON array of targets; each target should have name, workdir, image_tag, tag_command
      WORKDIR:
        required: false
        type: string
        default: .
      CICD_TEST_MODE:
        required: false
        type: string
        default: ""

jobs:

  # Run a standard build only on PR/MR create
  build-only:
    name: Container build
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    env:
      WORKDIR: ${{ inputs.WORKDIR }}
    steps:
      - uses: actions/checkout@v4
      - run: env | sort
      - run: df -h
      - run: rm -rf /opt/hostedtoolcache
      - run: df -h
      - run: docker build -t "${GITHUB_REPOSITORY}:$(date +%s)" .
        working-directory: ${{ env.WORKDIR }}

  # Run nvchecker/dfupdate, build/push when needed, and package artifacts per target.
  container-update:
    name: Automated container update (${{ matrix.target.name }})
    if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch' || inputs.CICD_TEST_MODE == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        target: ${{ fromJson(inputs.TARGETS_JSON != '' && inputs.TARGETS_JSON || format('[{{"name":"{0}","workdir":"{0}","image_tag":"{1}","tag_command":"{2}"}}]', inputs.WORKDIR, inputs.IMAGE_TAG, inputs.TAG_COMMAND)) }}
    env:
      WORKDIR: ${{ matrix.target.workdir }}
      TARGET_NAME: ${{ matrix.target.name }}
    steps:
      - uses: actions/checkout@v4
      - name: Resolve CICD workflow ref
        run: |
          workflow_ref="${{ github.workflow_ref }}"
          if [ -n "${workflow_ref}" ]; then
            repo="${workflow_ref%%/.github/workflows/*}"
            ref="${workflow_ref##*@}"
          else
            repo="${GITHUB_REPOSITORY}"
            ref="${GITHUB_REF_NAME}"
          fi
          {
            echo "CICD_REPO=${repo}"
            echo "CICD_REF=${ref}"
          } >> "$GITHUB_ENV"
          if [ "${repo}" = "${GITHUB_REPOSITORY}" ] && [ -d "${GITHUB_WORKSPACE}/.github/scripts" ]; then
            {
              echo "CICD_REPO_DIR=${GITHUB_WORKSPACE}"
              echo "CICD_SCRIPTS_DIR=${GITHUB_WORKSPACE}/.github/scripts"
              echo "CICD_NEED_CHECKOUT=false"
            } >> "$GITHUB_ENV"
          else
            {
              echo "CICD_REPO_DIR=${GITHUB_WORKSPACE}/.cicd"
              echo "CICD_SCRIPTS_DIR=${GITHUB_WORKSPACE}/.cicd/.github/scripts"
              echo "CICD_NEED_CHECKOUT=true"
            } >> "$GITHUB_ENV"
          fi
      - name: Checkout CICD scripts
        uses: actions/checkout@v4
        if: env.CICD_NEED_CHECKOUT == 'true'
        with:
          repository: ${{ env.CICD_REPO }}
          ref: ${{ env.CICD_REF }}
          token: ${{ secrets.GITHUB_TOKEN || secrets.GH_TOKEN || github.token }}
          path: .cicd
          fetch-depth: 1
      - name: Compute target slug
        run: |
          TARGET_SLUG=$(echo "${TARGET_NAME}" | tr '/.' '-')
          echo "TARGET_SLUG=${TARGET_SLUG}" >> "$GITHUB_ENV"
      - run: echo "TAG_COMMAND=${{ matrix.target.tag_command || inputs.TAG_COMMAND }}" >> "$GITHUB_ENV"
      - run: echo "IMAGE_TAG=${{ matrix.target.image_tag || inputs.IMAGE_TAG }}" >> "$GITHUB_ENV"
      - run: env | sort
      - run: df -h
      - name: Run nvchecker (test mode)
        if: env.CICD_TEST_MODE == 'true'
        run: |
          "${GITHUB_WORKSPACE}/tests/workflows/stubs/nvchecker.sh"
        working-directory: ${{ env.WORKDIR }}
      - name: Run nvchecker
        if: env.CICD_TEST_MODE != 'true'
        run: docker run --rm --name nvchecker --mount "type=bind,source=${PWD},target=/data/" -w /data "snw35/nvchecker:${NVCHECKER_VERSION}" nvchecker -l debug -c nvchecker.toml
        working-directory: ${{ env.WORKDIR }}
      - name: Run dfupdate (test mode)
        if: env.CICD_TEST_MODE == 'true'
        run: |
          "${GITHUB_WORKSPACE}/tests/workflows/stubs/dfupdate.sh"
        working-directory: ${{ env.WORKDIR }}
      - name: Run dfupdate
        if: env.CICD_TEST_MODE != 'true'
        run: docker run --rm --name dfupdate --mount "type=bind,source=${PWD},target=/data/" -w /data "snw35/dfupdate:${DFUPDATE_VERSION}"
        working-directory: ${{ env.WORKDIR }}
      - name: Sync version snapshot
        run: |
          if [ -f new_ver.json ]; then
            owner="$(id -u):$(id -g)"
            if [ "${CICD_TEST_MODE:-}" = "true" ]; then
              cp new_ver.json old_ver.json
              chown "${owner}" old_ver.json
            else
              if command -v sudo >/dev/null 2>&1; then
                sudo cp new_ver.json old_ver.json
                sudo chown "${owner}" old_ver.json
              else
                cp new_ver.json old_ver.json
                chown "${owner}" old_ver.json
              fi
            fi
          fi
        working-directory: ${{ env.WORKDIR }}
      - id: check_changes
        run: |
          if [[ $(git -C "$GITHUB_WORKSPACE" status --porcelain | wc -l) -eq 0 ]]; then
            echo "No repository changes detected."
            echo "changed=false" >> "$GITHUB_OUTPUT"
          else
            echo "Repository changes detected."
            echo "changed=true" >> "$GITHUB_OUTPUT"
          fi
      - run: sudo chown "$(id -u):$(id -g)" Dockerfile
        if: env.CICD_TEST_MODE != 'true'
        working-directory: ${{ env.WORKDIR }}
      - run: |
          if [ -f new_ver.json ]; then
            sudo chown "$(id -u):$(id -g)" new_ver.json
          fi
        if: env.CICD_TEST_MODE != 'true'
        working-directory: ${{ env.WORKDIR }}
      - run: pip3 install dockerfile-parse --break-system-packages
      - run: |
          BASE_VERSION=$(python3 "$CICD_SCRIPTS_DIR/dockerfile_base_tag.py")
          echo "BASE_VERSION=${BASE_VERSION}" >> "$GITHUB_ENV"
        working-directory: ${{ env.WORKDIR }}
      - run: |
          ENV_VERSIONS=$(python3 "$CICD_SCRIPTS_DIR/dockerfile_envs.py" versions)
          echo "ENV_VERSIONS=${ENV_VERSIONS}" >> "$GITHUB_ENV"
        working-directory: ${{ env.WORKDIR }}
      - run: |
          if [[ ${{ env.WORKDIR }} == '.' ]]; then
            echo "PROPOSED_TAG=${ENV_VERSIONS}-${BASE_VERSION}" >> "$GITHUB_ENV"
          else
            echo "PROPOSED_TAG=${{ env.WORKDIR }}-${ENV_VERSIONS}-${BASE_VERSION}" >> "$GITHUB_ENV"
          fi
      - run: |
          if [[ -z "${IMAGE_TAG}" ]]; then
            echo "DOCKER_TAG=$PROPOSED_TAG" >> "$GITHUB_ENV"
          else
            IMAGE_TAG_VALUE=$(python3 "$CICD_SCRIPTS_DIR/dockerfile_envs.py" get "${IMAGE_TAG}")
            if [[ ${{ env.WORKDIR }} == '.' ]]; then
              echo "DOCKER_TAG=${IMAGE_TAG_VALUE}" >> "$GITHUB_ENV"
            else
              echo "DOCKER_TAG=${{ env.WORKDIR }}-${IMAGE_TAG_VALUE}" >> "$GITHUB_ENV"
            fi
          fi
        working-directory: ${{ env.WORKDIR }}
      - run: |
          if [[ -n "${TAG_COMMAND}" ]]; then
            if [[ ${{ env.WORKDIR }} == '.' ]]; then
              echo "DOCKER_TAG=$($TAG_COMMAND)" >> "$GITHUB_ENV"
            else
              echo "DOCKER_TAG=${{ env.WORKDIR }}-$($TAG_COMMAND)" >> "$GITHUB_ENV"
            fi
          fi
        working-directory: ${{ env.WORKDIR }}
      - id: check_tags
        run: |
          if [ "${CICD_TEST_MODE:-}" = "true" ]; then
            echo "Docker tag forced missing in test mode."
            echo "tag_exists=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          repo_url="https://${GH_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"
          if [ "$(git ls-remote --tags "$repo_url" "${DOCKER_TAG}" | wc -l)" -eq 0 ]; then
            echo "Docker tag does not exist on remote."
            echo "tag_exists=false" >> "$GITHUB_OUTPUT"
          else
            echo "Docker tag already exists on remote."
            echo "tag_exists=true" >> "$GITHUB_OUTPUT"
          fi
      - name: Set update variables
        run: |
          {
            echo "CHANGED=${{ steps.check_changes.outputs.changed }}"
            echo "TAG_EXISTS=${{ steps.check_tags.outputs.tag_exists }}"
            echo "IMAGE=${GITHUB_REPOSITORY}:${DOCKER_TAG}"
            echo "TARGET_NAME=${TARGET_NAME}"
          } >> "$GITHUB_ENV"
      - run: env | sort
      - run: echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "$GITHUB_REPOSITORY_OWNER" --password-stdin
        if: env.CICD_TEST_MODE != 'true' && (env.CHANGED == 'true' || env.TAG_EXISTS == 'false')
      - run: git clone --depth 1 https://github.com/docker-library/official-images.git ~/official-images
        if: env.CICD_TEST_MODE != 'true' && (env.CHANGED == 'true' || env.TAG_EXISTS == 'false')
      - run: rm -rf /opt/hostedtoolcache
        if: env.CICD_TEST_MODE != 'true' && (env.CHANGED == 'true' || env.TAG_EXISTS == 'false')
      - run: df -h
        if: env.CICD_TEST_MODE != 'true' && (env.CHANGED == 'true' || env.TAG_EXISTS == 'false')
      - run: docker build -t "$IMAGE" .
        if: env.CICD_TEST_MODE != 'true' && (env.CHANGED == 'true' || env.TAG_EXISTS == 'false')
        working-directory: ${{ env.WORKDIR }}
      - run: ~/official-images/test/run.sh "$IMAGE" || exit 1;
        if: env.CICD_TEST_MODE != 'true' && (env.CHANGED == 'true' || env.TAG_EXISTS == 'false')
      - run: docker push "$IMAGE"
        if: env.CICD_TEST_MODE != 'true' && (env.CHANGED == 'true' || env.TAG_EXISTS == 'false')
      - run: docker tag "$IMAGE" "${GITHUB_REPOSITORY}:${WORKDIR}"
        if: env.CICD_TEST_MODE != 'true' && (env.CHANGED == 'true' || env.TAG_EXISTS == 'false') && env.WORKDIR != '' && env.WORKDIR != '.'
      - run: docker push "${GITHUB_REPOSITORY}:${WORKDIR}"
        if: env.CICD_TEST_MODE != 'true' && (env.CHANGED == 'true' || env.TAG_EXISTS == 'false') && env.WORKDIR != '' && env.WORKDIR != '.'
      - run: docker tag "$IMAGE" "${GITHUB_REPOSITORY}:latest"
        if: env.CICD_TEST_MODE != 'true' && (env.CHANGED == 'true' || env.TAG_EXISTS == 'false') && (env.WORKDIR == '' || env.WORKDIR == '.')
      - run: docker push "${GITHUB_REPOSITORY}:latest"
        if: env.CICD_TEST_MODE != 'true' && (env.CHANGED == 'true' || env.TAG_EXISTS == 'false') && (env.WORKDIR == '' || env.WORKDIR == '.')
      - run: docker images
        if: env.CICD_TEST_MODE != 'true' && (env.CHANGED == 'true' || env.TAG_EXISTS == 'false')
      - name: Stage and package repository changes
        if: env.CHANGED == 'true' || env.TAG_EXISTS == 'false'
        run: |
          git -C "$GITHUB_WORKSPACE" add -A
          if git -C "$GITHUB_WORKSPACE" diff --cached --quiet; then
            echo "No repository changes to package for ${TARGET_NAME}"
          else
            git -C "$GITHUB_WORKSPACE" diff --binary --cached > "/tmp/${TARGET_SLUG}-changes.patch"
          fi
      - name: Refresh changed flag after packaging
        run: |
          if git -C "$GITHUB_WORKSPACE" diff --cached --quiet && git -C "$GITHUB_WORKSPACE" diff --quiet; then
            echo "CHANGED=false" >> "$GITHUB_ENV"
          else
            echo "CHANGED=true" >> "$GITHUB_ENV"
          fi
      - name: Write update metadata
        run: |
          cat > "/tmp/${TARGET_SLUG}-meta.json" <<EOF
          {
            "name": "${TARGET_NAME}",
            "workdir": "${WORKDIR}",
            "changed": "${CHANGED}",
            "tag_exists": "${TAG_EXISTS}",
            "proposed_tag": "${PROPOSED_TAG}",
            "docker_tag": "${DOCKER_TAG}",
            "image": "${IMAGE}"
          }
          EOF
      - name: Verify version snapshot (test mode)
        if: env.CICD_TEST_MODE == 'true'
        run: |
          if [ ! -f new_ver.json ]; then
            echo "new_ver.json missing in test mode" >&2
            exit 1
          fi
          if [ ! -f old_ver.json ]; then
            echo "old_ver.json missing in test mode" >&2
            exit 1
          fi
          if ! cmp -s new_ver.json old_ver.json; then
            echo "old_ver.json does not match new_ver.json in test mode" >&2
            exit 1
          fi
        working-directory: ${{ env.WORKDIR }}
      - uses: actions/upload-artifact@v4
        if: env.CICD_TEST_MODE != 'true'
        with:
          name: update-${{ env.TARGET_SLUG }}-${{ github.run_attempt }}
          path: |
            /tmp/${{ env.TARGET_SLUG }}-*
          if-no-files-found: error
          overwrite: true

  collect-metadata:
    name: Collect metadata
    needs: container-update
    if: >
      (github.event_name == 'schedule' || github.event_name == 'workflow_dispatch' || inputs.CICD_TEST_MODE == 'true')
      && needs.container-update.result != 'failure'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      changed_any: ${{ steps.collect.outputs.changed_any }}
      docker_tags: ${{ steps.collect.outputs.docker_tags }}
      proposed_tags: ${{ steps.collect.outputs.proposed_tags }}
      images: ${{ steps.collect.outputs.images }}
      targets_json: ${{ steps.collect.outputs.targets_json }}
    steps:
      - name: Resolve CICD workflow ref
        run: |
          workflow_ref="${{ github.workflow_ref }}"
          if [ -n "${workflow_ref}" ]; then
            repo="${workflow_ref%%/.github/workflows/*}"
            ref="${workflow_ref##*@}"
          else
            repo="${GITHUB_REPOSITORY}"
            ref="${GITHUB_REF_NAME}"
          fi
          {
            echo "CICD_REPO=${repo}"
            echo "CICD_REF=${ref}"
          } >> "$GITHUB_ENV"
          if [ "${repo}" = "${GITHUB_REPOSITORY}" ] && [ -d "${GITHUB_WORKSPACE}/.github/scripts" ]; then
            {
              echo "CICD_REPO_DIR=${GITHUB_WORKSPACE}"
              echo "CICD_SCRIPTS_DIR=${GITHUB_WORKSPACE}/.github/scripts"
              echo "CICD_NEED_CHECKOUT=false"
            } >> "$GITHUB_ENV"
          else
            {
              echo "CICD_REPO_DIR=${GITHUB_WORKSPACE}/.cicd"
              echo "CICD_SCRIPTS_DIR=${GITHUB_WORKSPACE}/.cicd/.github/scripts"
              echo "CICD_NEED_CHECKOUT=true"
            } >> "$GITHUB_ENV"
          fi
      - name: Checkout CICD scripts
        uses: actions/checkout@v4
        if: env.CICD_NEED_CHECKOUT == 'true'
        with:
          repository: ${{ env.CICD_REPO }}
          ref: ${{ env.CICD_REF }}
          token: ${{ secrets.GITHUB_TOKEN || secrets.GH_TOKEN || github.token }}
          path: .cicd
          fetch-depth: 1
      - uses: actions/download-artifact@v4
        if: env.CICD_TEST_MODE != 'true'
        with:
          pattern: update-*-${{ github.run_attempt }}
          path: /tmp/updates
          merge-multiple: true
        continue-on-error: true
      - id: collect
        run: python3 "$CICD_SCRIPTS_DIR/collect_updates.py"
