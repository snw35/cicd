name: Reuseable container workflow

env:
  NVCHECKER_VERSION: '2.20'
  DFUPDATE_VERSION: '2.2.2'
  GH_TOKEN: ${{ github.token }}

# Provide inputs that control image tagging
on:
  workflow_call:
    outputs:
      changed:
        description: Whether any matrix target detected Dockerfile changes or a missing tag
        value: ${{ jobs.collect-metadata.outputs.changed_any }}
      docker_tag:
        description: JSON map of Docker tags keyed by target name
        value: ${{ jobs.collect-metadata.outputs.docker_tags }}
      proposed_tag:
        description: JSON map of proposed tags keyed by target name
        value: ${{ jobs.collect-metadata.outputs.proposed_tags }}
      image:
        description: JSON map of full image references keyed by target name
        value: ${{ jobs.collect-metadata.outputs.images }}
      targets:
        description: JSON array of target metadata (name, workdir, changed, tag_exists, docker_tag, proposed_tag, image)
        value: ${{ jobs.collect-metadata.outputs.targets_json }}
    inputs:
      # Provide a bash command that will create the image tag
      TAG_COMMAND:
        required: false
        type: string
      # Provide a Dockerfile ENV var that will be used for the image tag
      IMAGE_TAG:
        required: false
        type: string
      TARGETS_JSON:
        required: false
        type: string
        description: JSON array of targets; each target should have name, workdir, image_tag, tag_command
      WORKDIR:
        required: false
        type: string
        default: .
      CICD_REF:
        required: false
        type: string
        default: "main"
        description: Ref (branch or tag) for CICD helper scripts.
      RUN_AUTOMATED_UPDATE_ON_PR:
        required: false
        type: boolean
        default: false
        description: Run automated container update job on pull_request instead of build-only.

jobs:

  # Run a standard build only on PR/MR create
  build-only:
    name: Container build
    if: github.event_name == 'pull_request' && inputs.RUN_AUTOMATED_UPDATE_ON_PR == false
    runs-on: ubuntu-latest
    env:
      WORKDIR: ${{ inputs.WORKDIR }}
    steps:
      - uses: actions/checkout@v4
      - run: env | sort
      - run: df -h
      - run: rm -rf /opt/hostedtoolcache
      - run: df -h
      - run: docker build -t "${GITHUB_REPOSITORY}:$(date +%s)" .
        working-directory: ${{ env.WORKDIR }}

  # Run nvchecker/dfupdate, build/push when needed, and package artifacts per target.
  container-update:
    name: Automated container update (${{ matrix.target.name }})
    if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch' || (github.event_name == 'pull_request' && inputs.RUN_AUTOMATED_UPDATE_ON_PR)
    runs-on: ubuntu-latest
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        target: ${{ fromJson(inputs.TARGETS_JSON != '' && inputs.TARGETS_JSON || format('[{{"name":"{0}","workdir":"{0}","image_tag":"{1}","tag_command":"{2}"}}]', inputs.WORKDIR, inputs.IMAGE_TAG, inputs.TAG_COMMAND)) }}
    env:
      WORKDIR: ${{ matrix.target.workdir }}
      TARGET_NAME: ${{ matrix.target.name }}
    steps:
      - uses: actions/checkout@v4
      - name: Resolve CICD helper repo
        env:
          INPUT_CICD_REF: ${{ inputs.CICD_REF }}
          INPUT_WORKFLOW_REF: ${{ github.workflow_ref }}
        run: |
          repo="snw35/cicd"
          ref="${INPUT_CICD_REF:-}"
          if [ -z "$ref" ]; then
            workflow_ref="${INPUT_WORKFLOW_REF:-}"
            if [ -n "$workflow_ref" ] && [ "${workflow_ref#*@}" != "$workflow_ref" ]; then
              ref="${workflow_ref##*@}"
            elif [ "$GITHUB_REPOSITORY" = "$repo" ] && [ -n "${GITHUB_REF_NAME:-}" ]; then
              ref="${GITHUB_REF_NAME}"
            else
              ref="main"
            fi
          fi
          if [ "$repo" = "$GITHUB_REPOSITORY" ] && [ -d "${GITHUB_WORKSPACE}/.github/scripts" ]; then
            repo_dir="${GITHUB_WORKSPACE}"
            scripts_dir="${repo_dir}/.github/scripts"
            need_checkout="false"
          else
            repo_dir="${GITHUB_WORKSPACE}/.cicd"
            scripts_dir="${repo_dir}/.github/scripts"
            need_checkout="true"
          fi
          {
            echo "CICD_REPO=$repo"
            echo "CICD_REF=$ref"
            echo "CICD_REPO_DIR=$repo_dir"
            echo "CICD_SCRIPTS_DIR=$scripts_dir"
            echo "CICD_NEED_CHECKOUT=$need_checkout"
          } >> "$GITHUB_ENV"
      - name: Checkout CICD scripts
        if: env.CICD_NEED_CHECKOUT == 'true'
        uses: actions/checkout@v4
        with:
          repository: ${{ env.CICD_REPO }}
          ref: ${{ env.CICD_REF }}
          token: ${{ secrets.GITHUB_TOKEN || secrets.GH_TOKEN || github.token }}
          path: .cicd
          fetch-depth: 1
      - name: Ignore CICD helper checkout
        if: env.CICD_NEED_CHECKOUT == 'true'
        run: |
          exclude_file="${GITHUB_WORKSPACE}/.git/info/exclude"
          if [ -f "${exclude_file}" ] && ! grep -qx "/.cicd/" "${exclude_file}"; then
            echo "/.cicd/" >> "${exclude_file}"
          fi
      - name: Compute target slug
        run: |
          TARGET_SLUG=$(echo "${TARGET_NAME}" | tr '/.' '-')
          echo "TARGET_SLUG=${TARGET_SLUG}" >> "$GITHUB_ENV"
      - run: echo "TAG_COMMAND=${{ matrix.target.tag_command || inputs.TAG_COMMAND }}" >> "$GITHUB_ENV"
      - run: echo "IMAGE_TAG=${{ matrix.target.image_tag || inputs.IMAGE_TAG }}" >> "$GITHUB_ENV"
      - run: env | sort
      - run: df -h
      - name: Run nvchecker
        run: docker run --rm --name nvchecker --mount "type=bind,source=${PWD},target=/data/" -w /data "snw35/nvchecker:${NVCHECKER_VERSION}" nvchecker -l debug -c nvchecker.toml
        working-directory: ${{ env.WORKDIR }}
      - name: Run dfupdate
        run: docker run --rm --name dfupdate --mount "type=bind,source=${PWD},target=/data/" -w /data "snw35/dfupdate:${DFUPDATE_VERSION}"
        working-directory: ${{ env.WORKDIR }}
      - name: Sync version snapshot
        run: |
          if [ -f new_ver.json ]; then
            owner="$(id -u):$(id -g)"
            if command -v sudo >/dev/null 2>&1; then
              sudo cp new_ver.json old_ver.json
              sudo chown "${owner}" old_ver.json
            else
              cp new_ver.json old_ver.json
              chown "${owner}" old_ver.json
            fi
          fi
        working-directory: ${{ env.WORKDIR }}
      - id: check_changes
        run: |
          if [[ $(git -C "$GITHUB_WORKSPACE" status --porcelain | wc -l) -eq 0 ]]; then
            echo "No repository changes detected."
            echo "changed=false" >> "$GITHUB_OUTPUT"
          else
            echo "Repository changes detected."
            echo "changed=true" >> "$GITHUB_OUTPUT"
          fi
      - run: sudo chown "$(id -u):$(id -g)" Dockerfile
        working-directory: ${{ env.WORKDIR }}
      - run: |
          if [ -f new_ver.json ]; then
            sudo chown "$(id -u):$(id -g)" new_ver.json
          fi
        working-directory: ${{ env.WORKDIR }}
      - run: pip3 install dockerfile-parse --break-system-packages
      - run: |
          BASE_VERSION=$(python3 "$CICD_SCRIPTS_DIR/dockerfile_base_tag.py")
          echo "BASE_VERSION=${BASE_VERSION}" >> "$GITHUB_ENV"
        working-directory: ${{ env.WORKDIR }}
      - id: env_versions
        run: |
          value="$(python3 "$CICD_SCRIPTS_DIR/dockerfile_envs.py" --path "Dockerfile" versions)"
          {
            echo "value<<EOF"
            echo "$value"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"
        working-directory: ${{ env.WORKDIR }}
      - run: echo "ENV_VERSIONS=${{ steps.env_versions.outputs.value }}" >> "$GITHUB_ENV"
      - run: |
          if [[ ${{ env.WORKDIR }} == '.' ]]; then
            echo "PROPOSED_TAG=${ENV_VERSIONS}-${BASE_VERSION}" >> "$GITHUB_ENV"
          else
            echo "PROPOSED_TAG=${{ env.WORKDIR }}-${ENV_VERSIONS}-${BASE_VERSION}" >> "$GITHUB_ENV"
          fi
      - name: Set Docker tag from proposed tag
        if: env.IMAGE_TAG == ''
        run: echo "DOCKER_TAG=$PROPOSED_TAG" >> "$GITHUB_ENV"
      - id: image_tag_value
        if: env.IMAGE_TAG != ''
        run: |
          value="$(python3 "$CICD_SCRIPTS_DIR/dockerfile_envs.py" --path "Dockerfile" get "${IMAGE_TAG}")"
          {
            echo "value<<EOF"
            echo "$value"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"
        working-directory: ${{ env.WORKDIR }}
      - name: Set Docker tag from IMAGE_TAG
        if: env.IMAGE_TAG != ''
        run: |
          if [[ ${{ env.WORKDIR }} == '.' ]]; then
            echo "DOCKER_TAG=${{ steps.image_tag_value.outputs.value }}" >> "$GITHUB_ENV"
          else
            echo "DOCKER_TAG=${{ env.WORKDIR }}-${{ steps.image_tag_value.outputs.value }}" >> "$GITHUB_ENV"
          fi
      - run: |
          if [[ -n "${TAG_COMMAND}" ]]; then
            if [[ ${{ env.WORKDIR }} == '.' ]]; then
              echo "DOCKER_TAG=$($TAG_COMMAND)" >> "$GITHUB_ENV"
            else
              echo "DOCKER_TAG=${{ env.WORKDIR }}-$($TAG_COMMAND)" >> "$GITHUB_ENV"
            fi
          fi
        working-directory: ${{ env.WORKDIR }}
      - id: check_tags
        run: |
          repo_url="https://${GH_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"
          if [ "$(git ls-remote --tags "$repo_url" "${DOCKER_TAG}" | wc -l)" -eq 0 ]; then
            echo "Docker tag does not exist on remote."
            echo "tag_exists=false" >> "$GITHUB_OUTPUT"
          else
            echo "Docker tag already exists on remote."
            echo "tag_exists=true" >> "$GITHUB_OUTPUT"
          fi
      - name: Set update variables
        run: |
          {
            echo "CHANGED=${{ steps.check_changes.outputs.changed }}"
            echo "TAG_EXISTS=${{ steps.check_tags.outputs.tag_exists }}"
            echo "IMAGE=${GITHUB_REPOSITORY}:${DOCKER_TAG}"
            echo "TARGET_NAME=${TARGET_NAME}"
          } >> "$GITHUB_ENV"
      - run: env | sort
      - run: echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "$GITHUB_REPOSITORY_OWNER" --password-stdin
        if: env.CHANGED == 'true' || env.TAG_EXISTS == 'false'
      - run: git clone --depth 1 https://github.com/docker-library/official-images.git ~/official-images
        if: env.CHANGED == 'true' || env.TAG_EXISTS == 'false'
      - run: rm -rf /opt/hostedtoolcache
        if: env.CHANGED == 'true' || env.TAG_EXISTS == 'false'
      - run: df -h
        if: env.CHANGED == 'true' || env.TAG_EXISTS == 'false'
      - run: docker build -t "$IMAGE" .
        if: env.CHANGED == 'true' || env.TAG_EXISTS == 'false'
        working-directory: ${{ env.WORKDIR }}
      - name: Validate root docker-compose stack
        if: env.CHANGED == 'true' || env.TAG_EXISTS == 'false'
        run: |
          compose_file="${GITHUB_WORKSPACE}/docker-compose.yaml"
          if [ ! -f "${compose_file}" ]; then
            echo "No root docker-compose.yaml found. Skipping compose validation."
            exit 0
          fi

          resolved_compose="$(mktemp)"
          docker compose -f "${compose_file}" config > "${resolved_compose}"
          if grep -Eqi '^[[:space:]]*gpus:[[:space:]]*' "${resolved_compose}" \
            || grep -Eqi 'capabilities:[[:space:]]*\[[^]]*(^|[^[:alnum:]_])gpu([^[:alnum:]_]|$)[^]]*\]' "${resolved_compose}" \
            || awk '
              BEGIN { in_caps=0 }
              /^[[:space:]]*capabilities:[[:space:]]*$/ { in_caps=1; next }
              in_caps && /^[[:space:]]*-[[:space:]]*gpu([[:space:]]|$)/ { found=1; exit }
              in_caps && /^[[:space:]]*[A-Za-z0-9_.-]+:[[:space:]]*/ { in_caps=0 }
              in_caps && /^[^[:space:]]/ { in_caps=0 }
              END { exit(found ? 0 : 1) }
            ' "${resolved_compose}"; then
            echo "GPU pass-through detected in ${compose_file}; skipping compose validation on non-GPU runner."
            exit 0
          fi

          if [ -n "${WORKDIR}" ] && [ "${WORKDIR}" != "." ]; then
            docker tag "${IMAGE}" "${GITHUB_REPOSITORY}:${WORKDIR}"
          else
            docker tag "${IMAGE}" "${GITHUB_REPOSITORY}:latest"
          fi

          cleanup() {
            docker compose -f "${compose_file}" down --volumes --remove-orphans || true
          }
          trap cleanup EXIT

          echo "Running compose stack from ${compose_file} using locally built images"
          docker compose -f "${compose_file}" up -d --no-build --pull never
          sleep 10

          failed=0
          container_ids="$(docker compose -f "${compose_file}" ps -q)"
          for cid in ${container_ids}; do
            name="$(docker inspect --format '{{.Name}}' "${cid}" | sed 's#^/##')"
            status="$(docker inspect --format '{{.State.Status}}' "${cid}")"
            if [ "${status}" = "stopped" ] || [ "${status}" = "exited" ] || [ "${status}" = "dead" ] || [ "${status}" = "restarting" ]; then
              echo "::error::Compose container ${name} is in unhealthy state: ${status}"
              failed=1
            fi
          done

          if [ "${failed}" -ne 0 ]; then
            echo "::error::Compose validation failed because one or more containers are stopped/exited/dead or restarting."
            exit 1
          fi
      - run: ~/official-images/test/run.sh "$IMAGE" || exit 1;
        if: env.CHANGED == 'true' || env.TAG_EXISTS == 'false'
      - run: docker push "$IMAGE"
        if: env.CHANGED == 'true' || env.TAG_EXISTS == 'false'
      - run: docker tag "$IMAGE" "${GITHUB_REPOSITORY}:${WORKDIR}"
        if: (env.CHANGED == 'true' || env.TAG_EXISTS == 'false') && env.WORKDIR != '' && env.WORKDIR != '.'
      - run: docker push "${GITHUB_REPOSITORY}:${WORKDIR}"
        if: (env.CHANGED == 'true' || env.TAG_EXISTS == 'false') && env.WORKDIR != '' && env.WORKDIR != '.'
      - run: docker tag "$IMAGE" "${GITHUB_REPOSITORY}:latest"
        if: (env.CHANGED == 'true' || env.TAG_EXISTS == 'false') && (env.WORKDIR == '' || env.WORKDIR == '.')
      - run: docker push "${GITHUB_REPOSITORY}:latest"
        if: (env.CHANGED == 'true' || env.TAG_EXISTS == 'false') && (env.WORKDIR == '' || env.WORKDIR == '.')
      - run: docker images
        if: env.CHANGED == 'true' || env.TAG_EXISTS == 'false'
      - name: Stage and package repository changes
        if: env.CHANGED == 'true' || env.TAG_EXISTS == 'false'
        run: |
          git -C "$GITHUB_WORKSPACE" add -A
          if git -C "$GITHUB_WORKSPACE" diff --cached --quiet; then
            echo "No repository changes to package for ${TARGET_NAME}"
          else
            git -C "$GITHUB_WORKSPACE" diff --binary --cached > "/tmp/${TARGET_SLUG}-changes.patch"
          fi
      - name: Refresh changed flag after packaging
        run: |
          if git -C "$GITHUB_WORKSPACE" diff --cached --quiet && git -C "$GITHUB_WORKSPACE" diff --quiet; then
            echo "CHANGED=false" >> "$GITHUB_ENV"
          else
            echo "CHANGED=true" >> "$GITHUB_ENV"
          fi
      - name: Write update metadata
        run: |
          cat > "/tmp/${TARGET_SLUG}-meta.json" <<EOF
          {
            "name": "${TARGET_NAME}",
            "workdir": "${WORKDIR}",
            "changed": "${CHANGED}",
            "tag_exists": "${TAG_EXISTS}",
            "proposed_tag": "${PROPOSED_TAG}",
            "docker_tag": "${DOCKER_TAG}",
            "image": "${IMAGE}"
          }
          EOF
      - uses: actions/upload-artifact@v4
        with:
          name: update-${{ env.TARGET_SLUG }}-${{ github.run_attempt }}
          path: |
            /tmp/${{ env.TARGET_SLUG }}-*
          if-no-files-found: error
          overwrite: true

  collect-metadata:
    name: Collect metadata
    needs: container-update
    if: >
      (github.event_name == 'schedule' || github.event_name == 'workflow_dispatch')
      && needs.container-update.result != 'failure'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      changed_any: ${{ steps.collect.outputs.changed_any }}
      docker_tags: ${{ steps.collect.outputs.docker_tags }}
      proposed_tags: ${{ steps.collect.outputs.proposed_tags }}
      images: ${{ steps.collect.outputs.images }}
      targets_json: ${{ steps.collect.outputs.targets_json }}
    steps:
      - uses: actions/checkout@v4
      - name: Resolve CICD helper repo
        env:
          INPUT_CICD_REF: ${{ inputs.CICD_REF }}
          INPUT_WORKFLOW_REF: ${{ github.workflow_ref }}
        run: |
          repo="snw35/cicd"
          ref="${INPUT_CICD_REF:-}"
          if [ -z "$ref" ]; then
            workflow_ref="${INPUT_WORKFLOW_REF:-}"
            if [ -n "$workflow_ref" ] && [ "${workflow_ref#*@}" != "$workflow_ref" ]; then
              ref="${workflow_ref##*@}"
            elif [ "$GITHUB_REPOSITORY" = "$repo" ] && [ -n "${GITHUB_REF_NAME:-}" ]; then
              ref="${GITHUB_REF_NAME}"
            else
              ref="main"
            fi
          fi
          if [ "$repo" = "$GITHUB_REPOSITORY" ] && [ -d "${GITHUB_WORKSPACE}/.github/scripts" ]; then
            repo_dir="${GITHUB_WORKSPACE}"
            scripts_dir="${repo_dir}/.github/scripts"
            need_checkout="false"
          else
            repo_dir="${GITHUB_WORKSPACE}/.cicd"
            scripts_dir="${repo_dir}/.github/scripts"
            need_checkout="true"
          fi
          {
            echo "CICD_REPO=$repo"
            echo "CICD_REF=$ref"
            echo "CICD_REPO_DIR=$repo_dir"
            echo "CICD_SCRIPTS_DIR=$scripts_dir"
            echo "CICD_NEED_CHECKOUT=$need_checkout"
          } >> "$GITHUB_ENV"
      - name: Checkout CICD scripts
        if: env.CICD_NEED_CHECKOUT == 'true'
        uses: actions/checkout@v4
        with:
          repository: ${{ env.CICD_REPO }}
          ref: ${{ env.CICD_REF }}
          token: ${{ secrets.GITHUB_TOKEN || secrets.GH_TOKEN || github.token }}
          path: .cicd
          fetch-depth: 1
      - name: Ignore CICD helper checkout
        if: env.CICD_NEED_CHECKOUT == 'true'
        run: |
          exclude_file="${GITHUB_WORKSPACE}/.git/info/exclude"
          if [ -f "${exclude_file}" ] && ! grep -qx "/.cicd/" "${exclude_file}"; then
            echo "/.cicd/" >> "${exclude_file}"
          fi
      - uses: actions/download-artifact@v4
        with:
          pattern: update-*-${{ github.run_attempt }}
          path: /tmp/updates
          merge-multiple: true
        continue-on-error: true
      - id: collect
        env:
          UPDATES_DIR: /tmp/updates
        run: python3 "$CICD_SCRIPTS_DIR/collect_updates.py"
