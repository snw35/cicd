name: Reuseable container workflow

env:
  NVCHECKER_VERSION: 2.19
  DFUPDATE_VERSION: 2.2.2
  GH_TOKEN: ${{ github.token }}

# Provide inputs that control image tagging
on:
  workflow_call:
    outputs:
      changed:
        description: Whether any matrix target detected Dockerfile changes or a missing tag
        value: ${{ jobs.collect-metadata.outputs.changed_any }}
      docker_tag:
        description: JSON map of Docker tags keyed by target name
        value: ${{ jobs.collect-metadata.outputs.docker_tags }}
      proposed_tag:
        description: JSON map of proposed tags keyed by target name
        value: ${{ jobs.collect-metadata.outputs.proposed_tags }}
      image:
        description: JSON map of full image references keyed by target name
        value: ${{ jobs.collect-metadata.outputs.images }}
      targets:
        description: JSON array of target metadata (name, workdir, changed, tag_exists, docker_tag, proposed_tag, image)
        value: ${{ jobs.collect-metadata.outputs.targets_json }}
    inputs:
      # Provide a bash command that will create the image tag
      TAG_COMMAND:
        required: false
        type: string
      # Provide a Dockerfile ENV var that will be used for the image tag
      IMAGE_TAG:
        required: false
        type: string
      TARGETS_JSON:
        required: false
        type: string
        description: JSON array of targets; each target should have name, workdir, image_tag, tag_command
      WORKDIR:
        required: false
        type: string
        default: .
      CICD_REF:
        required: false
        type: string
        default: "mainline"
        description: Ref (branch or tag) for CICD helper scripts.

jobs:

  # Run a standard build only on PR/MR create
  build-only:
    name: Container build
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    env:
      WORKDIR: ${{ inputs.WORKDIR }}
    steps:
      - uses: actions/checkout@v4
      - run: env | sort
      - run: df -h
      - run: rm -rf /opt/hostedtoolcache
      - run: df -h
      - run: docker build -t "${GITHUB_REPOSITORY}:$(date +%s)" .
        working-directory: ${{ env.WORKDIR }}

  # Run nvchecker/dfupdate, build/push when needed, and package artifacts per target.
  container-update:
    name: Automated container update (${{ matrix.target.name }})
    if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        target: ${{ fromJson(inputs.TARGETS_JSON != '' && inputs.TARGETS_JSON || format('[{{"name":"{0}","workdir":"{0}","image_tag":"{1}","tag_command":"{2}"}}]', inputs.WORKDIR, inputs.IMAGE_TAG, inputs.TAG_COMMAND)) }}
    env:
      WORKDIR: ${{ matrix.target.workdir }}
      TARGET_NAME: ${{ matrix.target.name }}
    steps:
      - uses: actions/checkout@v4
      - name: Resolve CICD helper repo
        env:
          INPUT_CICD_REF: ${{ inputs.CICD_REF }}
        run: |
          repo="snw35/cicd"
          ref="${INPUT_CICD_REF:-}"
          if [ -z "$ref" ]; then
            if [ "$GITHUB_REPOSITORY" = "$repo" ] && [ -n "${GITHUB_REF_NAME:-}" ]; then
              ref="${GITHUB_REF_NAME}"
            else
              ref="mainline"
            fi
          fi
          if [ "$repo" = "$GITHUB_REPOSITORY" ] && [ -d "${GITHUB_WORKSPACE}/.github/scripts" ]; then
            repo_dir="${GITHUB_WORKSPACE}"
            scripts_dir="${repo_dir}/.github/scripts"
            need_checkout="false"
          else
            repo_dir="${GITHUB_WORKSPACE}/.cicd"
            scripts_dir="${repo_dir}/.github/scripts"
            need_checkout="true"
          fi
          {
            echo "CICD_REPO=$repo"
            echo "CICD_REF=$ref"
            echo "CICD_REPO_DIR=$repo_dir"
            echo "CICD_SCRIPTS_DIR=$scripts_dir"
            echo "CICD_NEED_CHECKOUT=$need_checkout"
          } >> "$GITHUB_ENV"
      - name: Checkout CICD scripts
        if: env.CICD_NEED_CHECKOUT == 'true'
        uses: actions/checkout@v4
        with:
          repository: ${{ env.CICD_REPO }}
          ref: ${{ env.CICD_REF }}
          token: ${{ secrets.GITHUB_TOKEN || secrets.GH_TOKEN || github.token }}
          path: .cicd
          fetch-depth: 1
      - name: Ignore CICD helper checkout
        if: env.CICD_NEED_CHECKOUT == 'true'
        run: |
          exclude_file="${GITHUB_WORKSPACE}/.git/info/exclude"
          if [ -f "${exclude_file}" ] && ! grep -qx "/.cicd/" "${exclude_file}"; then
            echo "/.cicd/" >> "${exclude_file}"
          fi
      - name: Compute target slug
        run: |
          TARGET_SLUG=$(echo "${TARGET_NAME}" | tr '/.' '-')
          echo "TARGET_SLUG=${TARGET_SLUG}" >> "$GITHUB_ENV"
      - run: echo "TAG_COMMAND=${{ matrix.target.tag_command || inputs.TAG_COMMAND }}" >> "$GITHUB_ENV"
      - run: echo "IMAGE_TAG=${{ matrix.target.image_tag || inputs.IMAGE_TAG }}" >> "$GITHUB_ENV"
      - run: env | sort
      - run: df -h
      - name: Run nvchecker
        run: docker run --rm --name nvchecker --mount "type=bind,source=${PWD},target=/data/" -w /data "snw35/nvchecker:${NVCHECKER_VERSION}" nvchecker -l debug -c nvchecker.toml
        working-directory: ${{ env.WORKDIR }}
      - name: Run dfupdate
        run: docker run --rm --name dfupdate --mount "type=bind,source=${PWD},target=/data/" -w /data "snw35/dfupdate:${DFUPDATE_VERSION}"
        working-directory: ${{ env.WORKDIR }}
      - name: Sync version snapshot
        run: |
          if [ -f new_ver.json ]; then
            owner="$(id -u):$(id -g)"
            if command -v sudo >/dev/null 2>&1; then
              sudo cp new_ver.json old_ver.json
              sudo chown "${owner}" old_ver.json
            else
              cp new_ver.json old_ver.json
              chown "${owner}" old_ver.json
            fi
          fi
        working-directory: ${{ env.WORKDIR }}
      - id: check_changes
        run: |
          if [[ $(git -C "$GITHUB_WORKSPACE" status --porcelain | wc -l) -eq 0 ]]; then
            echo "No repository changes detected."
            echo "changed=false" >> "$GITHUB_OUTPUT"
          else
            echo "Repository changes detected."
            echo "changed=true" >> "$GITHUB_OUTPUT"
          fi
      - run: sudo chown "$(id -u):$(id -g)" Dockerfile
        working-directory: ${{ env.WORKDIR }}
      - run: |
          if [ -f new_ver.json ]; then
            sudo chown "$(id -u):$(id -g)" new_ver.json
          fi
        working-directory: ${{ env.WORKDIR }}
      - run: pip3 install dockerfile-parse --break-system-packages
      - run: |
          BASE_VERSION=$(python3 "$CICD_SCRIPTS_DIR/dockerfile_base_tag.py")
          echo "BASE_VERSION=${BASE_VERSION}" >> "$GITHUB_ENV"
        working-directory: ${{ env.WORKDIR }}
      - id: env_versions
        run: |
          value="$(python3 "$CICD_SCRIPTS_DIR/dockerfile_envs.py" --path "Dockerfile" versions)"
          {
            echo "value<<EOF"
            echo "$value"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"
        working-directory: ${{ env.WORKDIR }}
      - run: echo "ENV_VERSIONS=${{ steps.env_versions.outputs.value }}" >> "$GITHUB_ENV"
      - run: |
          if [[ ${{ env.WORKDIR }} == '.' ]]; then
            echo "PROPOSED_TAG=${ENV_VERSIONS}-${BASE_VERSION}" >> "$GITHUB_ENV"
          else
            echo "PROPOSED_TAG=${{ env.WORKDIR }}-${ENV_VERSIONS}-${BASE_VERSION}" >> "$GITHUB_ENV"
          fi
      - name: Set Docker tag from proposed tag
        if: env.IMAGE_TAG == ''
        run: echo "DOCKER_TAG=$PROPOSED_TAG" >> "$GITHUB_ENV"
      - id: image_tag_value
        if: env.IMAGE_TAG != ''
        run: |
          value="$(python3 "$CICD_SCRIPTS_DIR/dockerfile_envs.py" --path "Dockerfile" get "${IMAGE_TAG}")"
          {
            echo "value<<EOF"
            echo "$value"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"
        working-directory: ${{ env.WORKDIR }}
      - name: Set Docker tag from IMAGE_TAG
        if: env.IMAGE_TAG != ''
        run: |
          if [[ ${{ env.WORKDIR }} == '.' ]]; then
            echo "DOCKER_TAG=${{ steps.image_tag_value.outputs.value }}" >> "$GITHUB_ENV"
          else
            echo "DOCKER_TAG=${{ env.WORKDIR }}-${{ steps.image_tag_value.outputs.value }}" >> "$GITHUB_ENV"
          fi
      - run: |
          if [[ -n "${TAG_COMMAND}" ]]; then
            if [[ ${{ env.WORKDIR }} == '.' ]]; then
              echo "DOCKER_TAG=$($TAG_COMMAND)" >> "$GITHUB_ENV"
            else
              echo "DOCKER_TAG=${{ env.WORKDIR }}-$($TAG_COMMAND)" >> "$GITHUB_ENV"
            fi
          fi
        working-directory: ${{ env.WORKDIR }}
      - id: check_tags
        run: |
          repo_url="https://${GH_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"
          if [ "$(git ls-remote --tags "$repo_url" "${DOCKER_TAG}" | wc -l)" -eq 0 ]; then
            echo "Docker tag does not exist on remote."
            echo "tag_exists=false" >> "$GITHUB_OUTPUT"
          else
            echo "Docker tag already exists on remote."
            echo "tag_exists=true" >> "$GITHUB_OUTPUT"
          fi
      - name: Set update variables
        run: |
          {
            echo "CHANGED=${{ steps.check_changes.outputs.changed }}"
            echo "TAG_EXISTS=${{ steps.check_tags.outputs.tag_exists }}"
            echo "IMAGE=${GITHUB_REPOSITORY}:${DOCKER_TAG}"
            echo "TARGET_NAME=${TARGET_NAME}"
          } >> "$GITHUB_ENV"
      - run: env | sort
      - run: echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "$GITHUB_REPOSITORY_OWNER" --password-stdin
        if: env.CHANGED == 'true' || env.TAG_EXISTS == 'false'
      - run: git clone --depth 1 https://github.com/docker-library/official-images.git ~/official-images
        if: env.CHANGED == 'true' || env.TAG_EXISTS == 'false'
      - run: rm -rf /opt/hostedtoolcache
        if: env.CHANGED == 'true' || env.TAG_EXISTS == 'false'
      - run: df -h
        if: env.CHANGED == 'true' || env.TAG_EXISTS == 'false'
      - run: docker build -t "$IMAGE" .
        if: env.CHANGED == 'true' || env.TAG_EXISTS == 'false'
        working-directory: ${{ env.WORKDIR }}
      - run: ~/official-images/test/run.sh "$IMAGE" || exit 1;
        if: env.CHANGED == 'true' || env.TAG_EXISTS == 'false'
      - run: docker push "$IMAGE"
        if: env.CHANGED == 'true' || env.TAG_EXISTS == 'false'
      - run: docker tag "$IMAGE" "${GITHUB_REPOSITORY}:${WORKDIR}"
        if: (env.CHANGED == 'true' || env.TAG_EXISTS == 'false') && env.WORKDIR != '' && env.WORKDIR != '.'
      - run: docker push "${GITHUB_REPOSITORY}:${WORKDIR}"
        if: (env.CHANGED == 'true' || env.TAG_EXISTS == 'false') && env.WORKDIR != '' && env.WORKDIR != '.'
      - run: docker tag "$IMAGE" "${GITHUB_REPOSITORY}:latest"
        if: (env.CHANGED == 'true' || env.TAG_EXISTS == 'false') && (env.WORKDIR == '' || env.WORKDIR == '.')
      - run: docker push "${GITHUB_REPOSITORY}:latest"
        if: (env.CHANGED == 'true' || env.TAG_EXISTS == 'false') && (env.WORKDIR == '' || env.WORKDIR == '.')
      - run: docker images
        if: env.CHANGED == 'true' || env.TAG_EXISTS == 'false'
      - name: Stage and package repository changes
        if: env.CHANGED == 'true' || env.TAG_EXISTS == 'false'
        run: |
          git -C "$GITHUB_WORKSPACE" add -A
          if git -C "$GITHUB_WORKSPACE" diff --cached --quiet; then
            echo "No repository changes to package for ${TARGET_NAME}"
          else
            git -C "$GITHUB_WORKSPACE" diff --binary --cached > "/tmp/${TARGET_SLUG}-changes.patch"
          fi
      - name: Refresh changed flag after packaging
        run: |
          if git -C "$GITHUB_WORKSPACE" diff --cached --quiet && git -C "$GITHUB_WORKSPACE" diff --quiet; then
            echo "CHANGED=false" >> "$GITHUB_ENV"
          else
            echo "CHANGED=true" >> "$GITHUB_ENV"
          fi
      - name: Write update metadata
        run: |
          cat > "/tmp/${TARGET_SLUG}-meta.json" <<EOF
          {
            "name": "${TARGET_NAME}",
            "workdir": "${WORKDIR}",
            "changed": "${CHANGED}",
            "tag_exists": "${TAG_EXISTS}",
            "proposed_tag": "${PROPOSED_TAG}",
            "docker_tag": "${DOCKER_TAG}",
            "image": "${IMAGE}"
          }
          EOF
      - uses: actions/upload-artifact@v4
        with:
          name: update-${{ env.TARGET_SLUG }}-${{ github.run_attempt }}
          path: |
            /tmp/${{ env.TARGET_SLUG }}-*
          if-no-files-found: error
          overwrite: true

  collect-metadata:
    name: Collect metadata
    needs: container-update
    if: >
      (github.event_name == 'schedule' || github.event_name == 'workflow_dispatch')
      && needs.container-update.result != 'failure'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      changed_any: ${{ steps.collect.outputs.changed_any }}
      docker_tags: ${{ steps.collect.outputs.docker_tags }}
      proposed_tags: ${{ steps.collect.outputs.proposed_tags }}
      images: ${{ steps.collect.outputs.images }}
      targets_json: ${{ steps.collect.outputs.targets_json }}
    steps:
      - uses: actions/checkout@v4
      - name: Resolve CICD helper repo
        env:
          INPUT_CICD_REF: ${{ inputs.CICD_REF }}
        run: |
          repo="snw35/cicd"
          ref="${INPUT_CICD_REF:-}"
          if [ -z "$ref" ]; then
            if [ "$GITHUB_REPOSITORY" = "$repo" ] && [ -n "${GITHUB_REF_NAME:-}" ]; then
              ref="${GITHUB_REF_NAME}"
            else
              ref="mainline"
            fi
          fi
          if [ "$repo" = "$GITHUB_REPOSITORY" ] && [ -d "${GITHUB_WORKSPACE}/.github/scripts" ]; then
            repo_dir="${GITHUB_WORKSPACE}"
            scripts_dir="${repo_dir}/.github/scripts"
            need_checkout="false"
          else
            repo_dir="${GITHUB_WORKSPACE}/.cicd"
            scripts_dir="${repo_dir}/.github/scripts"
            need_checkout="true"
          fi
          {
            echo "CICD_REPO=$repo"
            echo "CICD_REF=$ref"
            echo "CICD_REPO_DIR=$repo_dir"
            echo "CICD_SCRIPTS_DIR=$scripts_dir"
            echo "CICD_NEED_CHECKOUT=$need_checkout"
          } >> "$GITHUB_ENV"
      - name: Checkout CICD scripts
        if: env.CICD_NEED_CHECKOUT == 'true'
        uses: actions/checkout@v4
        with:
          repository: ${{ env.CICD_REPO }}
          ref: ${{ env.CICD_REF }}
          token: ${{ secrets.GITHUB_TOKEN || secrets.GH_TOKEN || github.token }}
          path: .cicd
          fetch-depth: 1
      - name: Ignore CICD helper checkout
        if: env.CICD_NEED_CHECKOUT == 'true'
        run: |
          exclude_file="${GITHUB_WORKSPACE}/.git/info/exclude"
          if [ -f "${exclude_file}" ] && ! grep -qx "/.cicd/" "${exclude_file}"; then
            echo "/.cicd/" >> "${exclude_file}"
          fi
      - uses: actions/download-artifact@v4
        with:
          pattern: update-*-${{ github.run_attempt }}
          path: /tmp/updates
          merge-multiple: true
        continue-on-error: true
      - id: collect
        env:
          UPDATES_DIR: /tmp/updates
        run: python3 "$CICD_SCRIPTS_DIR/collect_updates.py"
